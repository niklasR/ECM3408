\documentclass[11pt]{article}
\usepackage{hyperref}
\usepackage{pdfpages}
\usepackage{listings}
\usepackage[a4paper,margin=2cm]{geometry}

\usepackage[round]{natbib}

\begin{document}
    \lstset{
    	breaklines=true,
		numbers=left,
		showspaces=false, 
		showstringspaces=false,
    }
    \title{ECM3408 - CA1: Skydrive}
    \author{62007094}
    \date{\today}
    \maketitle
    
    \section{SQLite Database Creation}
    The following commands can be used to create a table called \texttt{documents}
    
    \begin{lstlisting}[basicstyle=\ttfamily]
$ sqlite3 skydrive.sqlite3sqlite > CREATE TABLE documents    ...> ( id INT PRIMARY KEY 
    ...> , name VARCHAR    ...> , message VARCHAR ); # sqlite does not impose length-limits on fields, so none is give..quit
    \end{lstlisting}
	
	\subsection{Testing}
	Script output of creating a database as described above, storing an unencrypted message and retrieving it:
	\begin{lstlisting}[basicstyle=\ttfamily]
bash-3.2$ sqlite3 skydrive.sqlite3
SQLite version 3.8.5 2014-08-15 22:37:57
Enter ".help" for usage hints.
sqlite> CREATE TABLE documents
   ...> ( id INT PRIMARY KEY
   ...> , name VARCHAR
   ...> , message VARCHAR );
sqlite> INSERT INTO documents VALUES
   ...> (1, "Name", "Message");
sqlite> SELECT * FROM documents;
1|Name|Message
sqlite>
\end{lstlisting}

\section{The Ruby Code}
Please note that the class \texttt{caesar} was implemented after a model-answer for the problem.
\begin{lstlisting}[language=Ruby]
#!/usr/bin/env ruby -wrequire "sqlite3"require "webrick"DATABASE = "skydrive.sqlite3"

def model_list()	db  = SQLite3::Database.new( DATABASE )	qry = "select id, name from documents;"
	hash = db.execute( qry )	db.close	return hashend
	
def model_show(id)	db  = SQLite3::Database.new( DATABASE )
	qry = "select message from documents "
	      "where id = \"#{id}\""
	val = db.get_first_value( qry)
	db.close
	return val
end

def view_show(message, shift)
    cipher = Caesar.initialise(shift)
    message_plain = cipher.decrypt(message)
    "<html>"                                            +
    "  <body>"                                          +
    "    <p>" + message_plain.to_s + "</p>              +    "  </body>"                                         +    "</html>"

def view_list(vals)
	output = "<html>"                                   +
	"  <body>"
	
	vals.each do |key, value|
	  output <<	 "<a href=\"/show/#{key}\">#{value}</a><br \>"
	end
	
	output << "    <form action=\"http://localhost:3000/list\""   +	"          method=\"GET\">"                         +	"      <input name=\"code\" value=\"Enter id\"/>"   +
	"      <input type=\"Submit\"/>"                    +	"    </form>"                                       +	"  </body>"                                         +	"</html>"
end


class Controller < WEBrick::HTTPServlet::AbstractServlet    def do_GET ( req, rsp )      case req.path        when "/list"          rsp.status = 200          rsp.content_type = "text/html"
          rsp.body = view_list( model_list() )
        when "/show"
          id = req.query[ "id" ] || ""
          rsp.status = 200
          rsp.contetn_type= "text/html"
          rsp.body = view_show( model_show(id), 3)
      end
    endend
    
class Caesar
  def initialise(shift, alphabet = ('a'..'z').to_a.join)
    chars = alphabet.chars.to_a
    @encrypter = Hash[chars.zip(chars.rotate(shift))]
    @decrypter = Hash[chars.zip(chars.rotate(-shift))]
  end

  def encrypt(string)
    @encrypter.values_at(*string.chars).join
  end

  def decrypt(string)
    @decrypter.values_at(*string.chars).join
  end
end


server = WEBrick::HTTPServer.new( :Port => 3000 )   server.mount( "/", Controller )   server.start

\end{lstlisting}
	

\end{document}
